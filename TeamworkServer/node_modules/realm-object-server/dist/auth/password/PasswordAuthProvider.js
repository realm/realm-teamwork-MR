"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const AuthProvider_1 = require("../AuthProvider");
const errors = require("../../errors");
const shared_1 = require("../../shared");
const crypto = require("crypto");
const PasswordRealm_1 = require("./PasswordRealm");
class PasswordAuthProvider extends AuthProvider_1.AuthProvider {
    constructor(params = {}) {
        super();
        this.name = 'password';
        this.autoCreateAdminUser = params.autoCreateAdminUser || false;
        this.saltLength = params.saltLength || 32;
        this.iterations = params.iterations || 10000;
        this.keyLength = params.keyLength || 512;
        this.digest = params.digest || "sha512";
    }
    start() {
        const _super = name => super[name];
        return __awaiter(this, void 0, void 0, function* () {
            yield _super("start").call(this);
            this.passwordRealm = yield this.service.server.realmFactory.open(PasswordRealm_1.PasswordRealm);
            if (this.autoCreateAdminUser) {
                try {
                    const foundUser = this.service.getUserByProviderId("password", 'realm-admin');
                    if (!foundUser) {
                        yield this.attemptToRegister('realm-admin', '', true);
                        this.service.logger.info('Autocreated realm-admin user');
                    }
                }
                catch (err) {
                    this.service.logger.error('Failed to autocreate realm-admin user', err);
                }
            }
        });
    }
    stop() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.passwordRealm) {
                this.passwordRealm.close();
            }
        });
    }
    authenticateOrCreateUser(body) {
        return __awaiter(this, void 0, void 0, function* () {
            let username = "";
            let password = "";
            let register = false;
            let isAdmin = undefined;
            if (body["user_info"]) {
                username = body["data"];
                password = body["user_info"]["password"];
                register = body["user_info"]["register"];
                isAdmin = body["user_info"]["is_admin"] || false;
            }
            else {
                username = body["username"];
                password = body["password"];
                register = body["register"] || false;
                isAdmin = body["is_admin"] || false;
            }
            if (!username) {
                throw new errors.realm.MissingParameters('username');
            }
            if (password === undefined || password === null) {
                throw new errors.realm.MissingParameters('password');
            }
            if (register) {
                return this.attemptToRegister(username, password);
            }
            else {
                return this.attemptToLogin(username, password);
            }
        });
    }
    update(user, data) {
        return __awaiter(this, void 0, void 0, function* () {
            const newPassword = data.new_password;
            if (!newPassword) {
                throw new errors.realm.MissingParameters('new_password');
            }
            const salt = yield this.createSalt(this.saltLength);
            const hash = yield this.hashPassword(newPassword, salt, this.iterations, this.keyLength, this.digest);
            this.passwordRealm.write(() => {
                this.passwordRealm.create('PasswordSaltHash', {
                    salt: salt.toString("base64"),
                    iterations: this.iterations,
                    keyLength: this.keyLength,
                    digest: this.digest,
                    hash: hash.toString("base64"),
                    userId: user.userId,
                }, true);
            });
            return {};
        });
    }
    deleteUser(userId) {
        return __awaiter(this, void 0, void 0, function* () {
            let userDeleted = false;
            this.passwordRealm.write(() => {
                const foundPassword = this.passwordRealm.objectForPrimaryKey('PasswordSaltHash', userId);
                if (foundPassword) {
                    userDeleted = true;
                    this.passwordRealm.delete(foundPassword);
                }
            });
            return userDeleted;
        });
    }
    hashPassword(clearTextPassword, salt, iterations, keyLength, digest) {
        return __awaiter(this, void 0, void 0, function* () {
            return shared_1.Promisify(crypto.pbkdf2.bind(crypto), clearTextPassword, salt, iterations, keyLength, digest);
        });
    }
    createSalt(saltLength) {
        return __awaiter(this, void 0, void 0, function* () {
            return shared_1.Promisify(crypto.randomBytes.bind(crypto), saltLength);
        });
    }
    comparePassword(candidatePassword, salt, iterations, keyLength, digest, hash) {
        return __awaiter(this, void 0, void 0, function* () {
            const hashedCandidatePassword = yield this.hashPassword(candidatePassword, salt, iterations, keyLength, digest);
            return hashedCandidatePassword.equals(hash);
        });
    }
    attemptToRegister(username, password, isAdmin) {
        return __awaiter(this, void 0, void 0, function* () {
            const foundUser = this.service.getUserByProviderId("password", username);
            if (foundUser) {
                throw new errors.realm.InvalidCredentials();
            }
            const user = yield this.service.createOrUpdateUser(username, "password", isAdmin ? true : false, null);
            const userId = user.userId;
            const salt = yield this.createSalt(this.saltLength);
            const hash = yield this.hashPassword(password, salt, this.iterations, this.keyLength, this.digest);
            this.passwordRealm.write(() => {
                this.passwordRealm.create('PasswordSaltHash', {
                    salt: salt.toString("base64"),
                    iterations: this.iterations,
                    keyLength: this.keyLength,
                    digest: this.digest,
                    hash: hash.toString("base64"),
                    userId: userId
                }, true);
            });
            return user;
        });
    }
    attemptToLogin(username, password) {
        return __awaiter(this, void 0, void 0, function* () {
            const foundUser = this.service.getUserByProviderId("password", username);
            if (!foundUser) {
                const salt = yield this.createSalt(this.saltLength);
                const hash = yield this.hashPassword(password, salt, this.iterations, this.keyLength, this.digest);
                throw new errors.realm.InvalidCredentials();
            }
            const foundPassword = this.passwordRealm.objectForPrimaryKey('PasswordSaltHash', foundUser.userId);
            if (!foundPassword) {
                const salt = yield this.createSalt(this.saltLength);
                const hash = yield this.hashPassword(password, salt, this.iterations, this.keyLength, this.digest);
                throw new errors.realm.InvalidCredentials();
            }
            const passwordMatch = yield this.comparePassword(password, new Buffer(foundPassword.salt, "base64"), foundPassword.iterations, foundPassword.keyLength, foundPassword.digest, new Buffer(foundPassword.hash, "base64"));
            if (!passwordMatch) {
                throw new errors.realm.InvalidCredentials();
            }
            return foundUser;
        });
    }
}
exports.PasswordAuthProvider = PasswordAuthProvider;
//# sourceMappingURL=PasswordAuthProvider.js.map