"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function addPathAndMethod(target, httpMethod, path, functionName) {
    let routes = Object.assign([], Reflect.get(target, 'routes') || []);
    routes.push({
        httpMethod: httpMethod,
        path: path,
        functionName: functionName
    });
    Reflect.set(target, 'routes', routes);
}
function Get(path) {
    return function (target, propertyKey, descriptor) {
        addPathAndMethod(target, 'get', path, propertyKey);
    };
}
exports.Get = Get;
function Post(path) {
    return function (target, propertyKey, descriptor) {
        addPathAndMethod(target, 'post', path, propertyKey);
    };
}
exports.Post = Post;
function Put(path) {
    return function (target, propertyKey, descriptor) {
        addPathAndMethod(target, 'put', path, propertyKey);
    };
}
exports.Put = Put;
function Delete(path) {
    return function (target, propertyKey, descriptor) {
        addPathAndMethod(target, 'delete', path, propertyKey);
    };
}
exports.Delete = Delete;
function Options(path) {
    return function (target, propertyKey, descriptor) {
        addPathAndMethod(target, 'options', path, propertyKey);
    };
}
exports.Options = Options;
function Head(path) {
    return function (target, propertyKey, descriptor) {
        addPathAndMethod(target, 'head', path, propertyKey);
    };
}
exports.Head = Head;
function Trace(path) {
    return function (target, propertyKey, descriptor) {
        addPathAndMethod(target, 'trace', path, propertyKey);
    };
}
exports.Trace = Trace;
function Patch(path) {
    return function (target, propertyKey, descriptor) {
        addPathAndMethod(target, 'patch', path, propertyKey);
    };
}
exports.Patch = Patch;
function All(path) {
    return function (target, propertyKey, descriptor) {
        addPathAndMethod(target, 'all', path, propertyKey);
    };
}
exports.All = All;
function Upgrade(path) {
    return function (target, propertyKey, descriptor) {
        let upgradeRoutes = Reflect.get(target, 'upgradeRoutes') || [];
        upgradeRoutes.push({
            functionName: propertyKey,
            path: path
        });
        Reflect.set(target, 'upgradeRoutes', upgradeRoutes);
    };
}
exports.Upgrade = Upgrade;
function MiddlewaresBefore(...middlewares) {
    return function (target, propertyKey, descriptor) {
        let middlewaresBefore = Reflect.get(target, 'middlewaresBefore') || [];
        const flattenedMiddlewares = [].concat.apply([], middlewares);
        const newSetOfMiddlewares = middlewaresBefore.concat(flattenedMiddlewares);
        Reflect.set(target, 'middlewaresBefore', newSetOfMiddlewares);
    };
}
exports.MiddlewaresBefore = MiddlewaresBefore;
function BaseRoute(path) {
    return function (target) {
        Reflect.set(target, 'baseRoute', path);
    };
}
exports.BaseRoute = BaseRoute;
function ServiceName(name) {
    return function (target) {
        Reflect.set(target, 'serviceName', name);
    };
}
exports.ServiceName = ServiceName;
function Tags(tags) {
    return function (target) {
        Reflect.set(target, 'tags', tags);
    };
}
exports.Tags = Tags;
function ServeStatic(route, staticRoot) {
    return function (target) {
        let original = target;
        let f = function (...args) {
            const instance = new original(...args);
            let serveStaticRoutes = Reflect.get(target, 'serveStaticRoutes') || [];
            serveStaticRoutes.push({
                path: route,
                staticRoot: staticRoot
            });
            Reflect.set(instance, 'serveStaticRoutes', serveStaticRoutes);
            return instance;
        };
        f.prototype = original.prototype;
        return f;
    };
}
exports.ServeStatic = ServeStatic;
function Body(keyPath) {
    return function (target, functionName, argumentIndex) {
        let bodyParams = Reflect.get(target, 'parameterArguments') || [];
        bodyParams.push({
            functionName: functionName,
            argumentIndex: argumentIndex,
            type: 'body',
            keyPath: keyPath
        });
        Reflect.set(target, 'parameterArguments', bodyParams);
    };
}
exports.Body = Body;
function Headers(keyPath) {
    return function (target, functionName, argumentIndex) {
        let bodyParams = Reflect.get(target, 'parameterArguments') || [];
        bodyParams.push({
            functionName: functionName,
            argumentIndex: argumentIndex,
            type: 'headers',
            keyPath: keyPath
        });
        Reflect.set(target, 'parameterArguments', bodyParams);
    };
}
exports.Headers = Headers;
function Params(keyPath) {
    return function (target, functionName, argumentIndex) {
        let bodyParams = Reflect.get(target, 'parameterArguments') || [];
        bodyParams.push({
            functionName: functionName,
            argumentIndex: argumentIndex,
            type: 'params',
            keyPath: keyPath
        });
        Reflect.set(target, 'parameterArguments', bodyParams);
    };
}
exports.Params = Params;
function Query(keyPath) {
    return function (target, functionName, argumentIndex) {
        let bodyParams = Reflect.get(target, 'parameterArguments') || [];
        bodyParams.push({
            functionName: functionName,
            argumentIndex: argumentIndex,
            type: 'query',
            keyPath: keyPath
        });
        Reflect.set(target, 'parameterArguments', bodyParams);
    };
}
exports.Query = Query;
function Request() {
    return function (target, functionName, argumentIndex) {
        let bodyParams = Reflect.get(target, 'parameterArguments') || [];
        bodyParams.push({
            functionName: functionName,
            argumentIndex: argumentIndex,
            type: 'request'
        });
        Reflect.set(target, 'parameterArguments', bodyParams);
    };
}
exports.Request = Request;
function Response() {
    return function (target, functionName, argumentIndex) {
        let bodyParams = Reflect.get(target, 'parameterArguments') || [];
        bodyParams.push({
            functionName: functionName,
            argumentIndex: argumentIndex,
            type: 'response'
        });
        Reflect.set(target, 'parameterArguments', bodyParams);
    };
}
exports.Response = Response;
function Socket() {
    return function (target, functionName, argumentIndex) {
        let bodyParams = Reflect.get(target, 'parameterArguments') || [];
        bodyParams.push({
            functionName: functionName,
            argumentIndex: argumentIndex,
            type: 'socket'
        });
        Reflect.set(target, 'parameterArguments', bodyParams);
    };
}
exports.Socket = Socket;
function HeadBuffer() {
    return function (target, functionName, argumentIndex) {
        let bodyParams = Reflect.get(target, 'parameterArguments') || [];
        bodyParams.push({
            functionName: functionName,
            argumentIndex: argumentIndex,
            type: 'headBuffer'
        });
        Reflect.set(target, 'parameterArguments', bodyParams);
    };
}
exports.HeadBuffer = HeadBuffer;
function Next() {
    return function (target, functionName, argumentIndex) {
        let bodyParams = Reflect.get(target, 'parameterArguments') || [];
        bodyParams.push({
            functionName: functionName,
            argumentIndex: argumentIndex,
            type: 'response'
        });
        Reflect.set(target, 'parameterArguments', bodyParams);
    };
}
exports.Next = Next;
function Start() {
    return function (target, propertyKey, descriptor) {
        Reflect.set(target, 'startFunctionName', propertyKey);
    };
}
exports.Start = Start;
function Stop() {
    return function (target, propertyKey, descriptor) {
        Reflect.set(target, 'stopFunctionName', propertyKey);
    };
}
exports.Stop = Stop;
function ServerStarted() {
    return function (target, propertyKey, descriptor) {
        Reflect.set(target, 'serverStartedFunctionName', propertyKey);
    };
}
exports.ServerStarted = ServerStarted;
function Address() {
    return function (target, propertyKey, descriptor) {
        Reflect.set(target, 'addressFunctionName', propertyKey);
    };
}
exports.Address = Address;
function Unmute(contextual = true) {
    return function (target, propertyKey, descriptor) {
        if (contextual) {
            Reflect.set(target, 'unmuteContextualFunctionName', propertyKey);
        }
        else {
            Reflect.set(target, 'unmuteFunctionName', propertyKey);
        }
    };
}
exports.Unmute = Unmute;
//# sourceMappingURL=decorators.js.map