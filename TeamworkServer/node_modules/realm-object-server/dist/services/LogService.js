"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Logger_1 = require("../shared/Logger");
const decorators_1 = require("../decorators");
const CircularBuffer = require("circular-buffer");
const uws = require("uws");
const http_1 = require("http");
const net_1 = require("net");
let LogService = class LogService {
    constructor() {
        this.logger = new Logger_1.Mute();
        this.rootLogger = new Logger_1.Mute();
        this.buffers = {};
        for (let level in Logger_1.levels) {
            this.buffers[level] = new CircularBuffer(1000);
        }
        this.wss = new uws.Server({ noServer: true });
    }
    appendTestEntries() {
        const entryCount = 1500;
        const levels = Object.keys(Logger_1.levels);
        for (let e = 0; e <= entryCount; e++) {
            const level = levels[e % levels.length];
            this.logger.log(level, `Test message number ${e}`);
        }
        return `Generated ${entryCount} log entries`;
    }
    streamLogs(req, socket, head, level) {
        return __awaiter(this, void 0, void 0, function* () {
            const client = yield this.upgradeWebSocket(req, socket, head);
            const listener = (messageLevel, message, context = {}) => {
                if (this.isRelevantLevel(messageLevel, level)) {
                    if (!context.timestamp) {
                        context.timestamp = new Date();
                    }
                    const entry = {
                        level: messageLevel,
                        message,
                        context
                    };
                    client.send(JSON.stringify([entry]));
                }
            };
            this.logger.debug("WebSocket client connected, adding a listener");
            client.on("close", () => {
                this.logger.debug("WebSocket closed, removing the listener");
                this.rootLogger.removeListener("message", listener);
            });
            this.rootLogger.addListener("message", listener);
            const entries = this.buffers[level].toarray().map(({ level, msg, ctx }) => {
                return {
                    level,
                    message: msg,
                    context: ctx || {}
                };
            });
            client.send(JSON.stringify(entries));
        });
    }
    streamFatalLogs(req, socket, head) {
        return this.streamLogs(req, socket, head, 'fatal');
    }
    streamErrorLogs(req, socket, head) {
        return this.streamLogs(req, socket, head, 'error');
    }
    streamWarnLogs(req, socket, head) {
        return this.streamLogs(req, socket, head, 'warn');
    }
    streamInfoLogs(req, socket, head) {
        return this.streamLogs(req, socket, head, 'info');
    }
    streamDetailLogs(req, socket, head) {
        return this.streamLogs(req, socket, head, 'detail');
    }
    streamDebugLogs(req, socket, head) {
        return this.streamLogs(req, socket, head, 'debug');
    }
    streamTraceLogs(req, socket, head) {
        return this.streamLogs(req, socket, head, 'trace');
    }
    streamAllLogs(req, socket, head) {
        return this.streamLogs(req, socket, head, 'all');
    }
    setRootLogger(l) {
        this.rootLogger = l;
    }
    setLogger(l) {
        this.logger = l;
    }
    message(level, msg, ctx) {
        for (let bufferLevel in this.buffers) {
            if (this.isRelevantLevel(level, bufferLevel)) {
                const timestampedCtx = Object.assign({}, ctx, { timestamp: new Date() });
                this.buffers[bufferLevel].enq({ level, msg, ctx: timestampedCtx });
            }
        }
    }
    isRelevantLevel(actualLevel, targetLevel) {
        return Logger_1.levels[targetLevel] >= Logger_1.levels[actualLevel];
    }
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            this.listener = this.message.bind(this);
            this.rootLogger.on('message', this.listener);
        });
    }
    stop() {
        return __awaiter(this, void 0, void 0, function* () {
            this.rootLogger.removeListener('message', this.listener);
        });
    }
    upgradeWebSocket(req, socket, head) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                this.wss.handleUpgrade(req, socket, head, (client) => {
                    resolve(client);
                });
            });
        });
    }
};
__decorate([
    decorators_1.Get('/generate-test-entries'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], LogService.prototype, "appendTestEntries", null);
__decorate([
    decorators_1.Upgrade('/fatal'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [http_1.IncomingMessage, net_1.Socket, Object]),
    __metadata("design:returntype", void 0)
], LogService.prototype, "streamFatalLogs", null);
__decorate([
    decorators_1.Upgrade('/error'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [http_1.IncomingMessage, net_1.Socket, Object]),
    __metadata("design:returntype", void 0)
], LogService.prototype, "streamErrorLogs", null);
__decorate([
    decorators_1.Upgrade('/warn'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [http_1.IncomingMessage, net_1.Socket, Object]),
    __metadata("design:returntype", void 0)
], LogService.prototype, "streamWarnLogs", null);
__decorate([
    decorators_1.Upgrade('/info'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [http_1.IncomingMessage, net_1.Socket, Object]),
    __metadata("design:returntype", void 0)
], LogService.prototype, "streamInfoLogs", null);
__decorate([
    decorators_1.Upgrade('/detail'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [http_1.IncomingMessage, net_1.Socket, Object]),
    __metadata("design:returntype", void 0)
], LogService.prototype, "streamDetailLogs", null);
__decorate([
    decorators_1.Upgrade('/debug'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [http_1.IncomingMessage, net_1.Socket, Object]),
    __metadata("design:returntype", void 0)
], LogService.prototype, "streamDebugLogs", null);
__decorate([
    decorators_1.Upgrade('/trace'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [http_1.IncomingMessage, net_1.Socket, Object]),
    __metadata("design:returntype", void 0)
], LogService.prototype, "streamTraceLogs", null);
__decorate([
    decorators_1.Upgrade('/all'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [http_1.IncomingMessage, net_1.Socket, Object]),
    __metadata("design:returntype", void 0)
], LogService.prototype, "streamAllLogs", null);
__decorate([
    decorators_1.Unmute(false),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Logger_1.Logger]),
    __metadata("design:returntype", void 0)
], LogService.prototype, "setRootLogger", null);
__decorate([
    decorators_1.Unmute(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Logger_1.Logger]),
    __metadata("design:returntype", void 0)
], LogService.prototype, "setLogger", null);
__decorate([
    decorators_1.Start(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], LogService.prototype, "start", null);
__decorate([
    decorators_1.Stop(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], LogService.prototype, "stop", null);
LogService = __decorate([
    decorators_1.BaseRoute('/log'),
    decorators_1.ServiceName('log'),
    __metadata("design:paramtypes", [])
], LogService);
exports.LogService = LogService;
//# sourceMappingURL=LogService.js.map