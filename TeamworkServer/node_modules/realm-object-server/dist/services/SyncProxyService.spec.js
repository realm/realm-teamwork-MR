"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const sinon = require("sinon");
const chai = require("chai");
chai.use(require("chai-as-promised"));
const proxyquire = require("proxyquire");
const TestServer_1 = require("../TestServer");
const Token_1 = require("../shared/Token");
const SyncService_1 = require("../services/SyncService");
describe('SyncProxyService', () => {
    let service;
    let server;
    let httpProxy;
    let proxy;
    let syncService;
    beforeEach(() => __awaiter(this, void 0, void 0, function* () {
        server = new TestServer_1.TestServer();
        proxy = {
            on: sinon.stub(),
            ws: sinon.stub(),
            close: sinon.stub(),
        };
        httpProxy = {
            createProxy: sinon.stub().returns(proxy),
        };
        const { SyncProxyService } = proxyquire("./SyncProxyService", { 'http-proxy': httpProxy });
        service = new SyncProxyService();
        syncService = new SyncService_1.SyncService();
        yield server.start({
            services: [service, syncService]
        });
    }));
    afterEach(() => __awaiter(this, void 0, void 0, function* () {
        yield server.shutdown().catch((err) => { });
    }));
    function runHandler(service, req) {
        return __awaiter(this, void 0, void 0, function* () {
            const socket = { on: sinon.stub(), destroy: sinon.stub() };
            const head = sinon.stub();
            yield service.websocketHandler(req, socket, head);
            return socket;
        });
    }
    function createAuthorizationHeader(token, version = 1) {
        return `Realm-Access-Token version=${version} token="${token.sign(server.privateKey)}"`;
    }
    const validToken = new Token_1.AccessToken({
        access: ["download"],
        identity: "some-user",
        appId: "io.realm.Test",
        path: "/some-uid/myrealm",
        syncLabel: "default",
    });
    const adminToken = new Token_1.AccessToken({
        access: ["download"],
        identity: "__admin",
        appId: "io.realm.Test",
        syncLabel: "default",
    });
    const noSyncLabelToken = new Token_1.AccessToken({
        access: ["download"],
        identity: "some-user",
        appId: "io.realm.Test",
        path: "/some-uid/myrealm"
    });
    describe("websocketHandler", () => {
        describe("without an authorization header", () => {
            it("should reject with an error", () => __awaiter(this, void 0, void 0, function* () {
                yield chai_1.assert.isRejected(runHandler(service, {
                    headers: {},
                }), "Authorization header was not provided");
            }));
        });
        describe("with an invalid access token header", () => {
            it("should reject with an error", () => __awaiter(this, void 0, void 0, function* () {
                yield chai_1.assert.isRejected(runHandler(service, {
                    headers: {
                        'authorization': "gibberish",
                    },
                }), "Authorization header is not in a valid format");
            }));
        });
        describe("with a valid access token header", () => {
            it("should open a proxy connection", () => __awaiter(this, void 0, void 0, function* () {
                yield chai_1.assert.isFulfilled(runHandler(service, {
                    headers: {
                        'authorization': createAuthorizationHeader(validToken),
                    },
                    params: {
                        path: "/some-uid/myrealm",
                    }
                }));
                sinon.assert.calledOnce(httpProxy.createProxy);
                sinon.assert.calledTwice(proxy.on);
                sinon.assert.calledOnce(proxy.ws);
            }));
            describe("with mismatching path parameters", () => {
                describe("as a regular user", () => {
                    it("should reject with an error", () => __awaiter(this, void 0, void 0, function* () {
                        yield chai_1.assert.isRejected(runHandler(service, {
                            headers: {
                                'authorization': createAuthorizationHeader(validToken),
                            },
                            params: {
                                path: "/some-uid/otherrealm",
                            }
                        }), "Your request parameters did not validate.");
                    }));
                });
                describe("as an admin user", () => {
                    it("should fulfill", () => __awaiter(this, void 0, void 0, function* () {
                        yield chai_1.assert.isFulfilled(runHandler(service, {
                            headers: {
                                'authorization': createAuthorizationHeader(adminToken),
                            },
                            params: {
                                path: "/some-uid/otherrealm",
                            }
                        }));
                        sinon.assert.calledOnce(httpProxy.createProxy);
                        sinon.assert.calledTwice(proxy.on);
                        sinon.assert.calledOnce(proxy.ws);
                    }));
                });
            });
            describe("without a syncLabel", () => {
                it("should lookup the location", () => __awaiter(this, void 0, void 0, function* () {
                    const stub = sinon.stub(service, "findSyncLabelForPath").returns(undefined);
                    yield chai_1.assert.isRejected(runHandler(service, {
                        headers: {
                            'authorization': createAuthorizationHeader(noSyncLabelToken),
                        },
                        params: {
                            path: "/some-uid/myrealm",
                        }
                    }), "AccessToken is not valid: sync label was not found in token");
                    sinon.assert.calledWith(stub, "/some-uid/myrealm");
                }));
            });
        });
        describe("sync service failover", () => {
            it("should close existing connection", () => __awaiter(this, void 0, void 0, function* () {
                const socket = yield chai_1.assert.isFulfilled(runHandler(service, {
                    headers: {
                        'authorization': createAuthorizationHeader(validToken),
                    },
                    params: {
                        path: "/some-uid/myrealm",
                    }
                }));
                sinon.assert.calledOnce(proxy.ws);
                sinon.assert.notCalled(proxy.close);
                yield server.discovery.deregisterService(syncService);
                sinon.assert.calledOnce(proxy.close);
                sinon.assert.calledOnce(socket.destroy);
                yield chai_1.assert.isRejected(runHandler(service, {
                    headers: {
                        'authorization': createAuthorizationHeader(validToken),
                    },
                    params: {
                        path: "/some-uid/myrealm",
                    }
                }), "Backend service is unavailable");
            }));
        });
    });
    describe("stop", () => {
        describe("with existing connections", () => {
            it("should close existing connections", () => __awaiter(this, void 0, void 0, function* () {
                const socket = yield chai_1.assert.isFulfilled(runHandler(service, {
                    headers: {
                        'authorization': createAuthorizationHeader(validToken),
                    },
                    params: {
                        path: "/some-uid/myrealm",
                    }
                }));
                yield server.shutdown();
                sinon.assert.calledOnce(proxy.close);
                sinon.assert.calledOnce(socket.destroy);
            }));
        });
    });
});
//# sourceMappingURL=SyncProxyService.spec.js.map