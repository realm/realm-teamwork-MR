"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Discovery_1 = require("./Discovery");
const ServiceWatch_1 = require("./ServiceWatch");
function isElement(element, superset) {
    return superset.indexOf(element) !== -1;
}
;
function isSubset(subset, superset) {
    return subset.every((element) => isElement(element, superset));
}
;
class SingleProcessDiscovery extends Discovery_1.Discovery {
    constructor() {
        super(...arguments);
        this.serviceHandles = [];
        this.serviceWatches = [];
    }
    registerService(service, address, port) {
        return __awaiter(this, void 0, void 0, function* () {
            const name = Reflect.get(service.constructor, 'serviceName');
            if (name) {
                const serviceHandle = { name, address, port, tags: service.tags || [] };
                this.serviceHandles.push(serviceHandle);
                this.emitServiceHandle("available", serviceHandle);
            }
        });
    }
    deregisterService(service) {
        return __awaiter(this, void 0, void 0, function* () {
            const serviceName = Reflect.get(service.constructor, 'serviceName');
            if (serviceName) {
                const serviceHandle = this.serviceHandles.find(s => s.name === serviceName);
                if (serviceHandle) {
                    let index = this.serviceHandles.indexOf(serviceHandle);
                    if (index >= 0) {
                        this.serviceHandles.splice(index, 1);
                    }
                    this.emitServiceHandle("unavailable", serviceHandle);
                }
            }
        });
    }
    findAll(name, tags) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.serviceHandles.filter((handle) => {
                return handle.name === name;
            }).filter((handle) => {
                if (tags) {
                    let found = false;
                    for (const t of tags) {
                        if (handle.tags.find(t2 => t2 === t)) {
                            found = true;
                        }
                    }
                    return found;
                }
                else {
                    return true;
                }
            });
        });
    }
    watchService(name, tags) {
        const watch = new ServiceWatch_1.ServiceWatch(name, tags);
        this.serviceWatches.push(watch);
        this.find(name, tags).then((handle) => {
            if (handle) {
                watch.emit('available', handle);
            }
        });
        return watch;
    }
    emitServiceHandle(event, handle) {
        for (const watch of this.serviceWatches) {
            if (watch.serviceName === handle.name && isSubset(watch.serviceTags, handle.tags)) {
                watch.emit(event, handle);
            }
        }
    }
}
exports.SingleProcessDiscovery = SingleProcessDiscovery;
//# sourceMappingURL=SingleProcessDiscovery.js.map